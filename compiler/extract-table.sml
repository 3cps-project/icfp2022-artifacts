(* This SML file can be used as a script for processing
 * the JSON files generated by the 3CPS compiler.
 *
 * To use, in the directory containing the generated JSON
 * files, run
 *
 *      echo "dumpTable();" | sml extract-table.sml
 *
 * which will print a LaTeX table to standard out.
 *)

CM.autoload "$/json-lib.cm";

(* benchmark names and lines of code *)
val bmarks = [
	("nucleic",             3326),
	("boyer",                838),
	("k-cfa",                591),
	("ratio-regions",        548),
	("mc-ray",               487),
	("knuth-bendix",         450),
	("raytracer",            333),
	("smith-normal-form",    290),
	("tsp",                  239),
	("cps-convert",          199),
	("interpreter",          178),
	("parser-comb",          168),
	("life",                 122),
	("derivative",           113),
	("nqueens",               45),
	("quicksort",             44),
	("mandelbrot",            43),
	("safe-for-space",        27),
	("cpstak",                21),
	("filter",                11),
	("tak",                   10),
	("ack",                    8)
      ];

val dyn_bmarks = [
	("k-cfa",                591),
	("raytracer",            333),
	("tsp",                  239),
	("cps-convert",          199),
	("interpreter",          178),
	("derivative",           113),
	("nqueens",               45),
	("quicksort",             44),
	("cpstak",                21),
	("filter",                11),
	("tak",                   10),
	("ack",                    8)
      ];

structure U = JSONUtil;

fun getJSON stem suffix trial = let
      val file = concat["src/examples/", stem, (*"-", *)suffix, (*"-", *) trial, ".json"]
      in
	JSONParser.parseFile file
      end

fun getAnalysisTime json = let
    (* check if a value is an object with the specified label *)
    fun labelIs s = U.testField "label" (fn v => U.asString v = s)
      val JSON.FLOAT t = U.get (json, [
	      U.SEL "timing",
	      U.SEL "kids", U.FIND (labelIs "CPS"),
	      U.SEL "kids", U.FIND (labelIs "CPS analysis"),
	      U.SEL "total"
	    ])
      in
	t
      end;

fun avgTime getTime getJSON = let
      fun get trial = getTime (getJSON trial)
      val times = List.map get [""] (* only do 1 trial for timing *)
      in
	0.1 * (List.foldl Real.+ 0.0 times)
      end;

fun getAvgTime stem = avgTime getAnalysisTime (getJSON stem "")

type extents = int * int * int	(* total / stack / reg *)

fun getExtents stem suffix = let
	val json = getJSON stem suffix "" (* "1" *)
      (* get the numbers from the convert stats *)
	val cvtData = U.asInt o U.lookupField (U.get (json, [
		U.SEL "compiler-stats",
		U.SEL "convert"
	      ]))
	fun getCvt (hf, sf, rf) = let
	      val h = cvtData hf
	      val s = cvtData sf
	      val r = cvtData rf
	      in
		(h+s+r, s, r)
	      end
	val cvtLVar = getCvt ("heap-lvar", "stk-lvar", "reg-lvar")
	val cvtTmp = getCvt ("heap-tmp-lvar", "stk-tmp-lvar", "reg-tmp-lvar")
	val cvtCVar = getCvt ("heap-tmp-cvar", "stk-tmp-cvar", "reg-tmp-cvar")
      (* get the numbers from the extents analysis *)
	val lvarData = U.lookupField (U.get (json, [
		U.SEL "extents",
		U.SEL "lvars"
	      ]))
	val total = U.asInt(lvarData "total")
	fun getEx fld = let
	      val get = U.asInt o U.lookupField (lvarData fld)
	      val stk = get "stk"
	      val reg = get "reg"
	      in
		(total, stk, reg)
	      end
	val synLVar = getEx "syntactic"
	val analLVar = getEx "analysis"
	val traceLVar = getEx "true"
	in
	  (cvtLVar, cvtTmp, cvtCVar, synLVar, analLVar, traceLVar)
	end;

fun getLambdaExtents stem suffix = let
	val json = getJSON stem suffix "" (* "1" *)
      (* get the numbers from the extents analysis *)
	val lvarData = U.lookupField (U.get (json, [
		U.SEL "extents",
		U.SEL "ldata"
	      ]))
	val total = U.asInt(lvarData "total")
	val get = U.asInt o U.lookupField (lvarData "analysis")
	val stk = get "stk"
	val reg = get "reg"
	in
	  (total, stk, reg)
	end;

structure F = Format;

(* generate a row of the LaTeX table.  The fields are:
 *	name,
 *	LOC,
 *	analysis time,
 *	# vars, syn stk, syn reg, anal stk, anal reg, % promote,
 *)
fun dumpRow (stem, loc) = let
     val t = getAvgTime stem
    (* variables *)
      val (_, _, _, (totalV, sStkV, sRegV), (_, aStkV, aRegV), (_, tStkV, tRegV)) = getExtents stem "" 
      val sHpV = totalV - sRegV - sStkV
      val aHpV = totalV - aRegV - aStkV
      val promotableV = totalV - (sStkV + sRegV)
      val promotedV = (aStkV + aRegV) - (sStkV + sRegV)
    (* lambdas *)
      val (totalL, regL, stkL) = getLambdaExtents stem "" 
      fun pct (a, b) = F.REAL(real(100 * a) / real b)
      in
	F.format
	  "    %s & %4d & %4d & %4d & %4d & %4d & %4d & %4d & %5.1f\\%% & %d & %d & %5.1f\\%% \\\\\n"
	  [
	    F.STR stem,
	    F.INT loc, F.INT(Real.round(1000.0 * t)),
	    F.INT totalV, F.INT sStkV, F.INT sRegV, F.INT aStkV, F.INT aRegV,
	    pct (promotedV, promotableV),
	    F.INT(regL + stkL), F.INT(totalL),
	    pct (regL + stkL, totalL)
	  ]
      end;

fun dumpTable () = List.app (print o dumpRow) bmarks;

fun getDynamicExtents stem suffix = let
	val json = getJSON stem suffix ""
        val static_prom = U.asInt o U.lookupField (U.get (json, [
                                                             U.SEL "promotions",
                                                             U.SEL "syntactic-to-analysis",
                                                             U.SEL "lvars"]))
        val (ssHp, ssStk, ssReg, saHp, saStk, saReg) =
            (static_prom ("H -> H") + static_prom ("H -> S") + static_prom ("H -> R") + static_prom ("H -> SR"),
             static_prom ("S -> S") + static_prom ("S -> SR"),
             static_prom ("R -> R") + static_prom ("R -> SR") + static_prom ("SR -> SR"),
            
             static_prom ("H -> H"),
             static_prom ("H -> S") + static_prom ("S -> S"),
             static_prom ("H -> R") + static_prom ("H -> SR") + static_prom ("R -> R") + static_prom ("S -> SR") + static_prom ("R -> SR") + static_prom ("SR -> SR"))
            

        val dyn_prom = U.asInt o U.lookupField (U.get (json, [
                                                          U.SEL "allocations",
                                                          U.SEL "syntactic-to-analysis",
                                                          U.SEL "lvars"]))
        val (dsHp, dsStk, dsReg, daHp, daStk, daReg) =
            (dyn_prom ("H -> H") + dyn_prom ("H -> S") + dyn_prom ("H -> R") + dyn_prom ("H -> SR"),
             dyn_prom ("S -> S") + dyn_prom ("S -> SR"),
             dyn_prom ("R -> R") + dyn_prom ("R -> SR") + dyn_prom ("SR -> SR"),
            
             dyn_prom ("H -> H"),
             dyn_prom ("H -> S") + dyn_prom ("S -> S"),
             dyn_prom ("H -> R") + dyn_prom ("H -> SR") + dyn_prom ("R -> R") + dyn_prom ("S -> SR") + dyn_prom ("R -> SR") + dyn_prom ("SR -> SR"))
            
	in
	    (ssHp, ssStk, ssReg, saHp, saStk, saReg,
             dsHp, dsStk, dsReg, daHp, daStk, daReg)
	end

fun dumpDynamicRow (stem, loc) = let
     val t = getAvgTime stem
    (* variables *)
     val (ssHp, ssStk, ssReg, saHp, saStk, saReg,
          dsHp, dsStk, dsReg, daHp, daStk, daReg) = getDynamicExtents stem ""
     val sTotal = ssHp + ssStk + ssReg
     val dTotal = dsHp + dsStk + dsReg

      val promotableS = sTotal - (ssStk + ssReg)
      val promotedS = (saStk + saReg) - (ssStk + ssReg)
      val promotableD = dTotal - (dsStk + dsReg)
      val promotedD = (daStk + daReg) - (dsStk + dsReg)
      fun pct (a, b) = F.REAL(real(100 * a) / real b)
      in
	F.format
	  "    %s & %4d & %4d & %4d & %4d & %4d & %5.1f\\%% & %d & %d & %d & %d & %d & %5.1f\\%% \\\\\n"
	  [
	    F.STR stem,
            F.INT sTotal, F.INT ssStk, F.INT ssReg, F.INT saStk, F.INT saReg, pct (promotedS, promotableS),
            F.INT dTotal, F.INT dsStk, F.INT dsReg, F.INT daStk, F.INT daReg, pct (promotedD, promotableD)
	  ]
      end;

fun dumpDynamicTable () = List.app (print o dumpDynamicRow) dyn_bmarks;
